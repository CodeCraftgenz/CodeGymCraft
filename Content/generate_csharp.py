import json, os

OUT = os.path.join(os.path.dirname(__file__), "challenges")
os.makedirs(OUT, exist_ok=True)

def save(data):
    with open(os.path.join(OUT, f"{data['id']}.json"), "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

TR = "public class TestResult { public bool Pass { get; set; } public string Message { get; set; } }"

def tc(body):
    return f"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class TestRunner\n{{\n    public static List<TestResult> RunTests()\n    {{\n        var results = new List<TestResult>();\n{body}\n        return results;\n    }}\n}}\n\n{TR}"

def eq(expr, expected, ok, fail):
    return f'        try {{ var r = {expr}; bool p = r == {expected}; results.Add(new TestResult {{ Pass = p, Message = p ? "{ok}" : "{fail}: " + r }}); }} catch (Exception ex) {{ results.Add(new TestResult {{ Pass = false, Message = "Erro: " + ex.Message }}); }}'

def eqs(expr, expected, ok, fail):
    return f'        try {{ var r = {expr}; bool p = r == "{expected}"; results.Add(new TestResult {{ Pass = p, Message = p ? "{ok}" : "{fail}: " + r }}); }} catch (Exception ex) {{ results.Add(new TestResult {{ Pass = false, Message = "Erro: " + ex.Message }}); }}'

def check(expr, ok, fail):
    return f'        try {{ bool p = {expr}; results.Add(new TestResult {{ Pass = p, Message = p ? "{ok}" : "{fail}" }}); }} catch (Exception ex) {{ results.Add(new TestResult {{ Pass = false, Message = "Erro: " + ex.Message }}); }}'

cs_ini = [
    ("Soma","Crie `Solution.Soma(int a, int b)` que retorna a soma.",["tipos","operador"],
     "public class Solution\n{\n    public static int Soma(int a, int b)\n    {\n        // Retorne a + b\n        return 0;\n    }\n}",
     tc(eq("Solution.Soma(2, 3)","5","2+3=5!","Incorreto") + "\n" + eq("Solution.Soma(-1, 1)","0","-1+1=0!","Incorreto"))),
    ("Dobro","Crie `Solution.Dobro(int n)` retorna n*2.",["operador","função"],
     "public class Solution\n{\n    public static int Dobro(int n)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.Dobro(5)","10","5*2=10!","Incorreto") + "\n" + eq("Solution.Dobro(0)","0","0*2=0!","Incorreto"))),
    ("Par ou Ímpar","Crie `Solution.ParOuImpar(int n)` retorna 'par' ou 'ímpar'.",["if/else","condição"],
     "public class Solution\n{\n    public static string ParOuImpar(int n)\n    {\n        return \"\";\n    }\n}",
     tc(eqs("Solution.ParOuImpar(4)","par","4 é par!","Incorreto") + "\n" + eqs("Solution.ParOuImpar(7)","ímpar","7 é ímpar!","Incorreto"))),
    ("Valor Absoluto","Crie `Solution.Absoluto(int n)` sem Math.Abs.",["condição","math"],
     "public class Solution\n{\n    public static int Absoluto(int n)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.Absoluto(-5)","5","-5→5!","Incorreto") + "\n" + eq("Solution.Absoluto(3)","3","3→3!","Incorreto"))),
    ("Maior de Três","Crie `Solution.Maior(int a, int b, int c)`.",["if/else","comparação"],
     "public class Solution\n{\n    public static int Maior(int a, int b, int c)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.Maior(1, 5, 3)","5","5 é maior!","Incorreto") + "\n" + eq("Solution.Maior(9, 2, 7)","9","9 é maior!","Incorreto"))),
    ("Classificar Idade","Crie `Solution.Classificar(int idade)`: criança(<12), adolescente(<18), adulto.",["if/else","classificação"],
     "public class Solution\n{\n    public static string Classificar(int idade)\n    {\n        return \"\";\n    }\n}",
     tc(eqs("Solution.Classificar(8)","criança","8=criança!","Incorreto") + "\n" + eqs("Solution.Classificar(15)","adolescente","15=adolescente!","Incorreto") + "\n" + eqs("Solution.Classificar(25)","adulto","25=adulto!","Incorreto"))),
    ("Fatorial","Crie `Solution.Fatorial(int n)` iterativo.",["loop","math"],
     "public class Solution\n{\n    public static long Fatorial(int n)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.Fatorial(5)","120L","5!=120!","Incorreto") + "\n" + eq("Solution.Fatorial(0)","1L","0!=1!","Incorreto"))),
    ("Fibonacci","Crie `Solution.Fibonacci(int n)` retorna n-ésimo número.",["loop","sequência"],
     "public class Solution\n{\n    public static int Fibonacci(int n)\n    {\n        // 0, 1, 1, 2, 3, 5, 8...\n        return 0;\n    }\n}",
     tc(eq("Solution.Fibonacci(0)","0","F(0)=0!","Incorreto") + "\n" + eq("Solution.Fibonacci(6)","8","F(6)=8!","Incorreto"))),
    ("Contar Vogais","Crie `Solution.ContarVogais(string s)`.",["string","loop"],
     "public class Solution\n{\n    public static int ContarVogais(string s)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.ContarVogais(\"hello\")","2","hello=2!","Incorreto") + "\n" + eq("Solution.ContarVogais(\"aeiou\")","5","aeiou=5!","Incorreto"))),
    ("Inverter String","Crie `Solution.Inverter(string s)`.",["string","reverse"],
     "public class Solution\n{\n    public static string Inverter(string s)\n    {\n        return \"\";\n    }\n}",
     tc(eqs("Solution.Inverter(\"abc\")","cba","cba ok!","Incorreto") + "\n" + eqs("Solution.Inverter(\"hello\")","olleh","olleh ok!","Incorreto"))),
    ("É Palíndromo","Crie `Solution.Palindromo(string s)`.",["string","lógica"],
     "public class Solution\n{\n    public static bool Palindromo(string s)\n    {\n        return false;\n    }\n}",
     tc(check("Solution.Palindromo(\"aba\")","aba é palíndromo!","Incorreto") + "\n" + check("!Solution.Palindromo(\"abc\")","abc não é!","Incorreto"))),
    ("Converter Temperatura","Crie `Solution.CelsiusParaFahrenheit(double c)`.",["conversão","cálculo"],
     "public class Solution\n{\n    public static double CelsiusParaFahrenheit(double c)\n    {\n        return 0;\n    }\n}",
     tc(check("Math.Abs(Solution.CelsiusParaFahrenheit(0) - 32) < 0.01","0°C=32°F!","Incorreto") + "\n" + check("Math.Abs(Solution.CelsiusParaFahrenheit(100) - 212) < 0.01","100°C=212°F!","Incorreto"))),
    ("Array Máximo","Crie `Solution.Maximo(int[] arr)`.",["array","busca"],
     "public class Solution\n{\n    public static int Maximo(int[] arr)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.Maximo(new[]{1,5,3,9,2})","9","Max=9!","Incorreto"))),
    ("Array Mínimo","Crie `Solution.Minimo(int[] arr)`.",["array","busca"],
     "public class Solution\n{\n    public static int Minimo(int[] arr)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.Minimo(new[]{1,5,3,9,2})","1","Min=1!","Incorreto"))),
    ("Média","Crie `Solution.Media(int[] arr)`.",["array","cálculo"],
     "public class Solution\n{\n    public static double Media(int[] arr)\n    {\n        return 0;\n    }\n}",
     tc(check("Math.Abs(Solution.Media(new[]{1,2,3,4,5}) - 3.0) < 0.01","Média=3!","Incorreto"))),
    ("Contar Pares","Crie `Solution.ContarPares(int[] arr)`.",["array","contagem"],
     "public class Solution\n{\n    public static int ContarPares(int[] arr)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.ContarPares(new[]{1,2,3,4,5,6})","3","3 pares!","Incorreto"))),
    ("String Interpolation","Crie `Solution.Saudacao(string nome, int idade)`.",["string","interpolation"],
     "public class Solution\n{\n    public static string Saudacao(string nome, int idade)\n    {\n        // Retorne \"Olá, {nome}! Você tem {idade} anos.\"\n        return \"\";\n    }\n}",
     tc(eqs("Solution.Saudacao(\"Ana\", 25)","Olá, Ana! Você tem 25 anos.","Saudação ok!","Incorreto"))),
    ("Split e Join","Crie `Solution.InverterPalavras(string s)`.",["string","split"],
     "public class Solution\n{\n    public static string InverterPalavras(string s)\n    {\n        // \"hello world\" -> \"world hello\"\n        return \"\";\n    }\n}",
     tc(eqs("Solution.InverterPalavras(\"hello world\")","world hello","Invertido!","Incorreto"))),
    ("List Add/Remove","Crie `Solution.ManipularLista()` retorna lista [1,3,5].",["List","coleção"],
     "public class Solution\n{\n    public static List<int> ManipularLista()\n    {\n        // Crie lista, adicione 1,2,3,4,5, remova pares, retorne\n        return new List<int>();\n    }\n}",
     tc(check("Solution.ManipularLista().SequenceEqual(new[]{1,3,5})","[1,3,5] ok!","Incorreto"))),
    ("List Contains","Crie `Solution.Contem(List<string> lista, string item)`.",["List","busca"],
     "public class Solution\n{\n    public static bool Contem(List<string> lista, string item)\n    {\n        return false;\n    }\n}",
     tc(check("Solution.Contem(new List<string>{\"a\",\"b\",\"c\"}, \"b\")","Encontrado!","Incorreto") + "\n" + check("!Solution.Contem(new List<string>{\"a\",\"b\"}, \"z\")","Não encontrado!","Incorreto"))),
    ("Math Operations","Crie `Solution.Arredondar(double n)`.",["Math","arredondamento"],
     "public class Solution\n{\n    public static int Arredondar(double n)\n    {\n        // Use Math.Round com MidpointRounding.AwayFromZero\n        return 0;\n    }\n}",
     tc(eq("Solution.Arredondar(4.5)","5","4.5→5!","Incorreto") + "\n" + eq("Solution.Arredondar(4.4)","4","4.4→4!","Incorreto"))),
    ("Random","Crie `Solution.Aleatorio(int min, int max)` retorna aleatório.",["Random","range"],
     "public class Solution\n{\n    public static int Aleatorio(int min, int max)\n    {\n        return 0;\n    }\n}",
     tc(check("{ var r = Solution.Aleatorio(1, 10); return r >= 1 && r <= 10; }","No range!","Fora do range")),
     ),
    ("Nullable Type","Crie `Solution.SeguroDiv(int a, int b)` retorna int?.",["nullable","divisão"],
     "public class Solution\n{\n    public static int? SeguroDiv(int a, int b)\n    {\n        // Retorne null se b == 0\n        return null;\n    }\n}",
     tc(eq("Solution.SeguroDiv(10, 2)","(int?)5","10/2=5!","Incorreto") + "\n" + check("Solution.SeguroDiv(10, 0) == null","Div por 0 = null!","Incorreto"))),
    ("Enum","Crie enum `Cor` com Vermelho, Verde, Azul e método para string.",["enum","tipo"],
     "public enum Cor { Vermelho, Verde, Azul }\n\npublic class Solution\n{\n    public static string CorParaHex(Cor c)\n    {\n        // Vermelho=#FF0000, Verde=#00FF00, Azul=#0000FF\n        return \"\";\n    }\n}",
     tc(eqs("Solution.CorParaHex(Cor.Vermelho)","#FF0000","Vermelho ok!","Incorreto") + "\n" + eqs("Solution.CorParaHex(Cor.Azul)","#0000FF","Azul ok!","Incorreto"))),
    ("Switch Expression","Crie `Solution.DiaDaSemana(int n)` com switch.",["switch","expressão"],
     "public class Solution\n{\n    public static string DiaDaSemana(int n)\n    {\n        // 1=Domingo...7=Sábado\n        return \"\";\n    }\n}",
     tc(eqs("Solution.DiaDaSemana(1)","Domingo","1=Domingo!","Incorreto") + "\n" + eqs("Solution.DiaDaSemana(7)","Sábado","7=Sábado!","Incorreto"))),
    ("Operador Ternário","Crie `Solution.MaiorIdade(int idade)` retorna 'maior' ou 'menor'.",["ternário","condição"],
     "public class Solution\n{\n    public static string MaiorIdade(int idade)\n    {\n        // Use operador ternário\n        return \"\";\n    }\n}",
     tc(eqs("Solution.MaiorIdade(18)","maior","18=maior!","Incorreto") + "\n" + eqs("Solution.MaiorIdade(10)","menor","10=menor!","Incorreto"))),
    ("For Loop","Crie `Solution.Tabuada(int n)` retorna array com tabuada.",["loop","array"],
     "public class Solution\n{\n    public static int[] Tabuada(int n)\n    {\n        // Retorne [n*1, n*2, ..., n*10]\n        return new int[0];\n    }\n}",
     tc(check("Solution.Tabuada(3).SequenceEqual(new[]{3,6,9,12,15,18,21,24,27,30})","Tabuada do 3 ok!","Incorreto"))),
    ("While Loop","Crie `Solution.SomarDigitos(int n)` soma os dígitos.",["loop","math"],
     "public class Solution\n{\n    public static int SomarDigitos(int n)\n    {\n        // 123 -> 1+2+3 = 6\n        return 0;\n    }\n}",
     tc(eq("Solution.SomarDigitos(123)","6","123→6!","Incorreto") + "\n" + eq("Solution.SomarDigitos(9999)","36","9999→36!","Incorreto"))),
    ("Foreach","Crie `Solution.Concatenar(string[] arr)` junta todas.",["loop","string"],
     "public class Solution\n{\n    public static string Concatenar(string[] arr)\n    {\n        return \"\";\n    }\n}",
     tc(eqs("Solution.Concatenar(new[]{\"a\",\"b\",\"c\"})","abc","abc ok!","Incorreto"))),
    ("Array Sort","Crie `Solution.Ordenar(int[] arr)` ordena crescente.",["array","sort"],
     "public class Solution\n{\n    public static int[] Ordenar(int[] arr)\n    {\n        // Ordene e retorne\n        return arr;\n    }\n}",
     tc(check("Solution.Ordenar(new[]{3,1,4,1,5}).SequenceEqual(new[]{1,1,3,4,5})","Ordenado!","Incorreto"))),
]

for i,(t,d,tg,s,tcode) in enumerate(cs_ini,1):
    save({"id":f"csharp-ini-{i:03d}","track":"csharp","title":t,"description":d,"starterCode":s,
          "tags":tg,"difficulty":"Iniciante","validatorType":"csharp-tests","validatorConfig":{"testCode":tcode}})

cs_int = [
    ("LINQ Where","Use Where para filtrar pares.",["LINQ","filtro"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static List<int> Pares(List<int> nums)\n    {\n        // Use Where\n        return new List<int>();\n    }\n}",
     tc(check("Solution.Pares(new List<int>{1,2,3,4,5,6}).SequenceEqual(new[]{2,4,6})","Pares filtrados!","Incorreto"))),
    ("LINQ Select","Use Select para transformar.",["LINQ","projeção"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static List<int> Dobrar(List<int> nums)\n    {\n        // Use Select\n        return new List<int>();\n    }\n}",
     tc(check("Solution.Dobrar(new List<int>{1,2,3}).SequenceEqual(new[]{2,4,6})","Dobrado!","Incorreto"))),
    ("LINQ OrderBy","Use OrderBy.",["LINQ","ordenação"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static List<string> Ordenar(List<string> nomes)\n    {\n        return new List<string>();\n    }\n}",
     tc(check("Solution.Ordenar(new List<string>{\"Carlos\",\"Ana\",\"Bruna\"}).SequenceEqual(new[]{\"Ana\",\"Bruna\",\"Carlos\"})","Ordenado!","Incorreto"))),
    ("LINQ Aggregate","Use Sum e Average.",["LINQ","agregação"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static (int soma, double media) Calcular(List<int> nums)\n    {\n        return (0, 0);\n    }\n}",
     tc(check("{ var r = Solution.Calcular(new List<int>{1,2,3,4,5}); return r.soma == 15 && Math.Abs(r.media - 3.0) < 0.01; }","Soma=15, Média=3!","Incorreto"))),
    ("LINQ First/Last","Use First e Last.",["LINQ","acesso"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static (int primeiro, int ultimo) Extremos(List<int> nums)\n    {\n        return (0, 0);\n    }\n}",
     tc(check("{ var r = Solution.Extremos(new List<int>{5,3,8,1}); return r.primeiro == 5 && r.ultimo == 1; }","Extremos ok!","Incorreto"))),
    ("LINQ GroupBy","Use GroupBy.",["LINQ","agrupamento"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static Dictionary<string, int> ContarPorInicial(List<string> nomes)\n    {\n        // Agrupe por primeira letra, conte cada grupo\n        return new Dictionary<string, int>();\n    }\n}",
     tc(check("{ var r = Solution.ContarPorInicial(new List<string>{\"Ana\",\"Alice\",\"Bob\"}); return r[\"A\"] == 2 && r[\"B\"] == 1; }","Agrupado!","Incorreto"))),
    ("Classe com Props","Crie classe Pessoa com Nome e Idade.",["classe","propriedade"],
     "public class Pessoa\n{\n    // Propriedades Nome (string) e Idade (int)\n    // Método Apresentar() retorna \"Sou {Nome}, tenho {Idade} anos\"\n}\n\npublic class Solution\n{\n    public static string Teste()\n    {\n        var p = new Pessoa { Nome = \"Ana\", Idade = 25 };\n        return p.Apresentar();\n    }\n}",
     tc(eqs("Solution.Teste()","Sou Ana, tenho 25 anos","Apresentação ok!","Incorreto"))),
    ("Construtor","Crie classe com construtor.",["classe","construtor"],
     "public class Retangulo\n{\n    // Construtor com largura e altura\n    // Método Area() retorna largura * altura\n}\n\npublic class Solution\n{\n    public static int Teste() => new Retangulo(5, 3).Area();\n}",
     tc(eq("Solution.Teste()","15","5*3=15!","Incorreto"))),
    ("Herança","Crie Cachorro que herda de Animal.",["herança","OOP"],
     "public class Animal\n{\n    public string Nome { get; set; }\n    public virtual string Falar() => $\"{Nome} faz som\";\n}\n\npublic class Cachorro : Animal\n{\n    // Override Falar() para retornar \"{Nome} diz: Au au!\"\n}\n\npublic class Solution\n{\n    public static string Teste() => new Cachorro { Nome = \"Rex\" }.Falar();\n}",
     tc(eqs("Solution.Teste()","Rex diz: Au au!","Au au!","Incorreto"))),
    ("Override","Use virtual/override.",["OOP","polimorfismo"],
     "public abstract class Forma\n{\n    public abstract double Area();\n}\n\npublic class Circulo : Forma\n{\n    public double Raio { get; set; }\n    // Override Area() = π * r²\n}\n\npublic class Solution\n{\n    public static double Teste() => new Circulo { Raio = 5 }.Area();\n}",
     tc(check("Math.Abs(Solution.Teste() - Math.PI * 25) < 0.01","Área ok!","Incorreto"))),
    ("Interface","Implemente interface.",["interface","OOP"],
     "public interface ICalculavel\n{\n    double Calcular();\n}\n\npublic class Quadrado : ICalculavel\n{\n    public double Lado { get; set; }\n    // Implemente Calcular() retornando Lado²\n}\n\npublic class Solution\n{\n    public static double Teste() => new Quadrado { Lado = 4 }.Calcular();\n}",
     tc(check("Math.Abs(Solution.Teste() - 16) < 0.01","16 ok!","Incorreto"))),
    ("Generics","Crie classe genérica Caixa<T>.",["generics","tipo"],
     "public class Caixa<T>\n{\n    // Propriedade Conteudo de tipo T\n    // Método Abrir() retorna Conteudo\n}\n\npublic class Solution\n{\n    public static string Teste()\n    {\n        var c = new Caixa<string> { Conteudo = \"presente\" };\n        return c.Abrir();\n    }\n}",
     tc(eqs("Solution.Teste()","presente","Presente ok!","Incorreto"))),
    ("Dictionary","Use Dictionary.",["Dictionary","coleção"],
     "public class Solution\n{\n    public static Dictionary<string, int> ContarPalavras(string texto)\n    {\n        // Conte ocorrências de cada palavra\n        return new Dictionary<string, int>();\n    }\n}",
     tc(check("{ var r = Solution.ContarPalavras(\"oi oi tchau\"); return r[\"oi\"] == 2 && r[\"tchau\"] == 1; }","Contagem ok!","Incorreto"))),
    ("HashSet","Use HashSet para únicos.",["HashSet","coleção"],
     "public class Solution\n{\n    public static List<int> Unicos(List<int> nums)\n    {\n        // Use HashSet para remover duplicatas, mantenha ordem\n        return new List<int>();\n    }\n}",
     tc(check("Solution.Unicos(new List<int>{1,2,2,3,3}).SequenceEqual(new[]{1,2,3})","Únicos!","Incorreto"))),
    ("Queue e Stack","Use Stack para inverter.",["Stack","coleção"],
     "public class Solution\n{\n    public static string InverterComStack(string s)\n    {\n        // Use Stack<char>\n        return \"\";\n    }\n}",
     tc(eqs("Solution.InverterComStack(\"abc\")","cba","Invertido!","Incorreto"))),
    ("Try/Catch","Trate exceção de divisão.",["exception","tratamento"],
     "public class Solution\n{\n    public static string DivisaoSegura(int a, int b)\n    {\n        // Retorne resultado ou \"Erro: divisão por zero\"\n        return \"\";\n    }\n}",
     tc(eqs("Solution.DivisaoSegura(10, 2)","5","10/2=5!","Incorreto") + "\n" + eqs("Solution.DivisaoSegura(10, 0)","Erro: divisão por zero","Erro capturado!","Incorreto"))),
    ("Custom Exception","Crie exceção customizada.",["exception","custom"],
     "public class IdadeInvalidaException : Exception\n{\n    // Construtor com mensagem\n}\n\npublic class Solution\n{\n    public static void ValidarIdade(int idade)\n    {\n        // Lance IdadeInvalidaException se idade < 0 ou > 150\n    }\n}",
     tc(check("{ try { Solution.ValidarIdade(-1); return false; } catch (IdadeInvalidaException) { return true; } }","Exceção lançada!","Exceção não lançada") + "\n" + check("{ try { Solution.ValidarIdade(25); return true; } catch { return false; } }","25 é válido!","Não deveria lançar"))),
    ("Enum Avançado","Crie enum com método de extensão.",["enum","extensão"],
     "public enum Status { Ativo, Inativo, Pendente }\n\npublic static class StatusExtensions\n{\n    // Método de extensão Descricao() para Status\n    // Ativo=\"Em uso\", Inativo=\"Desativado\", Pendente=\"Aguardando\"\n}\n\npublic class Solution\n{\n    public static string Teste() => Status.Ativo.Descricao();\n}",
     tc(eqs("Solution.Teste()","Em uso","Em uso ok!","Incorreto"))),
    ("Struct","Crie struct Ponto.",["struct","tipo valor"],
     "public struct Ponto\n{\n    public double X { get; set; }\n    public double Y { get; set; }\n    // Método Distancia(Ponto outro)\n}\n\npublic class Solution\n{\n    public static double Teste()\n    {\n        var p1 = new Ponto { X = 0, Y = 0 };\n        var p2 = new Ponto { X = 3, Y = 4 };\n        return p1.Distancia(p2);\n    }\n}",
     tc(check("Math.Abs(Solution.Teste() - 5.0) < 0.01","Distância=5!","Incorreto"))),
    ("Tuple","Use ValueTuple.",["tuple","retorno"],
     "public class Solution\n{\n    public static (int min, int max) MinMax(List<int> nums)\n    {\n        return (0, 0);\n    }\n}",
     tc(check("{ var r = Solution.MinMax(new List<int>{3,1,4,1,5}); return r.min == 1 && r.max == 5; }","Min=1, Max=5!","Incorreto"))),
    ("StringBuilder","Use StringBuilder.",["string","performance"],
     "using System.Text;\n\npublic class Solution\n{\n    public static string Repetir(string s, int n)\n    {\n        // Use StringBuilder para repetir s n vezes\n        return \"\";\n    }\n}",
     tc(eqs("Solution.Repetir(\"ab\", 3)","ababab","ababab ok!","Incorreto"))),
    ("Expression Body","Use expression-bodied members.",["syntax","expressão"],
     "public class Circulo\n{\n    public double Raio { get; set; }\n    // Area como expression body => Math.PI * Raio * Raio\n    // Circunferencia como expression body\n}\n\npublic class Solution\n{\n    public static double Teste() => new Circulo { Raio = 1 }.Area;\n}",
     tc(check("Math.Abs(Solution.Teste() - Math.PI) < 0.01","π ok!","Incorreto"))),
    ("Property Validation","Propriedade com validação.",["propriedade","validação"],
     "public class Produto\n{\n    private double _preco;\n    public double Preco\n    {\n        get => _preco;\n        set\n        {\n            // Lance ArgumentException se value < 0\n            _preco = value;\n        }\n    }\n}\n\npublic class Solution\n{\n    public static bool Teste()\n    {\n        try { new Produto { Preco = -1 }; return false; }\n        catch (ArgumentException) { return true; }\n    }\n}",
     tc(check("Solution.Teste()","Validação ok!","Não validou"))),
    ("Static Members","Use membros estáticos.",["static","classe"],
     "public class Contador\n{\n    private static int _count = 0;\n    // Incrementar() incrementa _count\n    // Valor propriedade static retorna _count\n}\n\npublic class Solution\n{\n    public static int Teste()\n    {\n        Contador.Incrementar();\n        Contador.Incrementar();\n        Contador.Incrementar();\n        return Contador.Valor;\n    }\n}",
     tc(eq("Solution.Teste()","3","Count=3!","Incorreto"))),
    ("Params","Use params keyword.",["params","variádico"],
     "public class Solution\n{\n    public static int Somar(params int[] nums)\n    {\n        return 0;\n    }\n}",
     tc(eq("Solution.Somar(1, 2, 3)","6","1+2+3=6!","Incorreto") + "\n" + eq("Solution.Somar(10)","10","10 ok!","Incorreto"))),
    ("Named Parameters","Use parâmetros nomeados e opcionais.",["parâmetros","named"],
     "public class Solution\n{\n    public static string FormatarNome(string primeiro, string ultimo, string titulo = \"\")\n    {\n        // Se titulo vazio: \"primeiro ultimo\", senão \"titulo primeiro ultimo\"\n        return \"\";\n    }\n}",
     tc(eqs("Solution.FormatarNome(\"Ana\", \"Silva\")","Ana Silva","Sem título ok!","Incorreto") + "\n" + eqs("Solution.FormatarNome(\"Ana\", \"Silva\", titulo: \"Dra.\")","Dra. Ana Silva","Com título ok!","Incorreto"))),
    ("Pattern Matching","Use is pattern.",["pattern matching","tipo"],
     "public class Solution\n{\n    public static string Descrever(object obj)\n    {\n        // Use pattern matching: int->\"inteiro: N\", string->\"texto: S\", null->\"nulo\"\n        return \"\";\n    }\n}",
     tc(eqs("Solution.Descrever(42)","inteiro: 42","Inteiro ok!","Incorreto") + "\n" + eqs("Solution.Descrever(\"oi\")","texto: oi","Texto ok!","Incorreto") + "\n" + eqs("Solution.Descrever(null)","nulo","Nulo ok!","Incorreto"))),
    ("Abstract Class","Crie classe abstrata.",["abstract","OOP"],
     "public abstract class Veiculo\n{\n    public string Modelo { get; set; }\n    public abstract int Rodas();\n}\n\npublic class Carro : Veiculo\n{\n    // Rodas() retorna 4\n}\n\npublic class Moto : Veiculo\n{\n    // Rodas() retorna 2\n}\n\npublic class Solution\n{\n    public static int Teste() => new Carro { Modelo = \"Civic\" }.Rodas() + new Moto { Modelo = \"CB\" }.Rodas();\n}",
     tc(eq("Solution.Teste()","6","4+2=6!","Incorreto"))),
    ("Generic Constraints","Generics com where.",["generics","constraint"],
     "public interface INomeavel { string Nome { get; } }\n\npublic class Solution\n{\n    public static string PegarNome<T>(T item) where T : INomeavel\n    {\n        return item.Nome;\n    }\n}\n\npublic class Aluno : INomeavel { public string Nome { get; set; } }",
     tc(eqs("Solution.PegarNome(new Aluno { Nome = \"Carlos\" })","Carlos","Carlos ok!","Incorreto"))),
]

for i,(t,d,tg,s,tcode) in enumerate(cs_int,1):
    save({"id":f"csharp-int-{i:03d}","track":"csharp","title":t,"description":d,"starterCode":s,
          "tags":tg,"difficulty":"Intermediario","validatorType":"csharp-tests","validatorConfig":{"testCode":tcode}})

cs_adv = [
    ("Delegate","Crie e use delegates.",["delegate","função"],
     "public delegate int Operacao(int a, int b);\n\npublic class Solution\n{\n    public static int Executar(Operacao op, int a, int b) => op(a, b);\n    public static int Soma(int a, int b) => a + b;\n    public static int Teste() => Executar(Soma, 3, 4);\n}",
     tc(eq("Solution.Teste()","7","3+4=7!","Incorreto"))),
    ("Events","Crie classe com evento.",["evento","observer"],
     "public class Botao\n{\n    public event Action<string>? Clicado;\n    public void Clicar() => Clicado?.Invoke(\"clicou\");\n}\n\npublic class Solution\n{\n    public static string Teste()\n    {\n        string resultado = \"\";\n        var btn = new Botao();\n        btn.Clicado += msg => resultado = msg;\n        btn.Clicar();\n        return resultado;\n    }\n}",
     tc(eqs("Solution.Teste()","clicou","Evento ok!","Incorreto"))),
    ("Func e Action","Use Func<T> e Action<T>.",["func","action"],
     "public class Solution\n{\n    public static int Aplicar(Func<int, int> fn, int valor) => fn(valor);\n    public static int Teste() => Aplicar(x => x * x, 5);\n}",
     tc(eq("Solution.Teste()","25","5²=25!","Incorreto"))),
    ("Lambda Avançada","Use lambdas complexas.",["lambda","LINQ"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static List<string> Transformar(List<int> nums)\n    {\n        // Filtre pares, ordene decrescente, converta para \"N é par\"\n        return new List<string>();\n    }\n}",
     tc(check("{ var r = Solution.Transformar(new List<int>{5,2,8,1,4}); return r.Count == 2 && r[0] == \"8 é par\" && r[1] == \"4 é par\"; }","Transformado!","Incorreto"))),
    ("LINQ SelectMany","Use SelectMany.",["LINQ","flatten"],
     "using System.Linq;\n\npublic class Solution\n{\n    public static List<int> Achatar(List<List<int>> listas)\n    {\n        return new List<int>();\n    }\n}",
     tc(check("Solution.Achatar(new List<List<int>>{new(){1,2},new(){3,4}}).SequenceEqual(new[]{1,2,3,4})","Achatado!","Incorreto"))),
    ("Async Task","Crie método async.",["async","Task"],
     "using System.Threading.Tasks;\n\npublic class Solution\n{\n    public static async Task<int> CalcularAsync(int n)\n    {\n        await Task.Delay(1);\n        // Retorne n * n\n        return 0;\n    }\n}",
     tc(check("{ var r = Solution.CalcularAsync(5).GetAwaiter().GetResult(); return r == 25; }","25 ok!","Incorreto"))),
    ("Task WhenAll","Use Task.WhenAll.",["async","WhenAll"],
     "using System.Threading.Tasks;\n\npublic class Solution\n{\n    public static async Task<int[]> ExecutarTodas()\n    {\n        var t1 = Task.FromResult(1);\n        var t2 = Task.FromResult(2);\n        var t3 = Task.FromResult(3);\n        // Use WhenAll e retorne resultados\n        return new int[0];\n    }\n}",
     tc(check("Solution.ExecutarTodas().GetAwaiter().GetResult().SequenceEqual(new[]{1,2,3})","[1,2,3] ok!","Incorreto"))),
    ("Switch Expression","Switch expression avançado.",["pattern","switch"],
     "public class Solution\n{\n    public static string Classificar(object obj) => obj switch\n    {\n        // int i when i > 0 => \"positivo\"\n        // int i when i < 0 => \"negativo\"\n        // int => \"zero\"\n        // string s => $\"texto: {s}\"\n        // null => \"nulo\"\n        // _ => \"desconhecido\"\n        _ => \"\"\n    };\n}",
     tc(eqs("Solution.Classificar(5)","positivo","Positivo!","Incorreto") + "\n" + eqs("Solution.Classificar(-3)","negativo","Negativo!","Incorreto") + "\n" + eqs("Solution.Classificar(null)","nulo","Nulo!","Incorreto"))),
    ("Record","Crie um record.",["record","imutável"],
     "public record Coordenada(double X, double Y)\n{\n    // Adicione método Distancia(Coordenada outro)\n}\n\npublic class Solution\n{\n    public static double Teste()\n    {\n        var a = new Coordenada(0, 0);\n        var b = new Coordenada(3, 4);\n        return a.Distancia(b);\n    }\n}",
     tc(check("Math.Abs(Solution.Teste() - 5.0) < 0.01","Dist=5!","Incorreto"))),
    ("Init Only","Use init-only properties.",["init","propriedade"],
     "public class Config\n{\n    public string Nome { get; init; } = \"\";\n    public int Valor { get; init; }\n}\n\npublic class Solution\n{\n    public static string Teste()\n    {\n        var c = new Config { Nome = \"teste\", Valor = 42 };\n        return $\"{c.Nome}:{c.Valor}\";\n    }\n}",
     tc(eqs("Solution.Teste()","teste:42","teste:42!","Incorreto"))),
    ("Extension Method","Crie método de extensão.",["extensão","método"],
     "public static class StringExtensions\n{\n    // Método de extensão ContarPalavras() para string\n}\n\npublic class Solution\n{\n    public static int Teste() => \"hello world foo\".ContarPalavras();\n}",
     tc(eq("Solution.Teste()","3","3 palavras!","Incorreto"))),
    ("Indexer","Crie classe com indexer.",["indexer","acesso"],
     "public class Matriz\n{\n    private int[,] _data;\n    public Matriz(int rows, int cols) { _data = new int[rows, cols]; }\n    // Indexer this[int row, int col]\n}\n\npublic class Solution\n{\n    public static int Teste()\n    {\n        var m = new Matriz(2, 2);\n        m[0, 0] = 42;\n        return m[0, 0];\n    }\n}",
     tc(eq("Solution.Teste()","42","42 ok!","Incorreto"))),
    ("Operator Overloading","Sobrecarregue operador +.",["operador","sobrecarga"],
     "public class Vetor\n{\n    public double X { get; set; }\n    public double Y { get; set; }\n    // Sobrecarregue operator +(Vetor a, Vetor b)\n}\n\npublic class Solution\n{\n    public static double Teste()\n    {\n        var v = new Vetor{X=1,Y=2} + new Vetor{X=3,Y=4};\n        return v.X + v.Y;\n    }\n}",
     tc(check("Math.Abs(Solution.Teste() - 10.0) < 0.01","(1+3)+(2+4)=10!","Incorreto"))),
    ("Yield Return","Use yield return.",["iterator","yield"],
     "using System.Collections.Generic;\n\npublic class Solution\n{\n    public static IEnumerable<int> Pares(int ate)\n    {\n        // Use yield return para gerar pares de 2 até 'ate'\n        yield break;\n    }\n}",
     tc(check("Solution.Pares(10).SequenceEqual(new[]{2,4,6,8,10})","Pares até 10!","Incorreto"))),
    ("IComparable","Implemente IComparable.",["interface","comparação"],
     "public class Aluno : IComparable<Aluno>\n{\n    public string Nome { get; set; }\n    public double Nota { get; set; }\n    // CompareTo ordena por Nota decrescente\n}\n\npublic class Solution\n{\n    public static string Teste()\n    {\n        var lista = new List<Aluno> { new(){Nome=\"B\",Nota=7}, new(){Nome=\"A\",Nota=9} };\n        lista.Sort();\n        return lista[0].Nome;\n    }\n}",
     tc(eqs("Solution.Teste()","A","A primeiro (nota 9)!","Incorreto"))),
    ("IDisposable","Implemente Dispose pattern.",["dispose","recurso"],
     "public class Recurso : IDisposable\n{\n    public bool Aberto { get; private set; } = true;\n    public void Dispose() { Aberto = false; }\n}\n\npublic class Solution\n{\n    public static bool Teste()\n    {\n        Recurso r;\n        using (r = new Recurso()) { /* usa recurso */ }\n        return !r.Aberto;\n    }\n}",
     tc(check("Solution.Teste()","Dispose ok!","Não fez dispose"))),
    ("Generic Method","Método genérico com constraint.",["generics","método"],
     "public class Solution\n{\n    public static T MaiorDe<T>(T a, T b) where T : IComparable<T>\n    {\n        // Retorne o maior\n        return default!;\n    }\n}",
     tc(eq("Solution.MaiorDe(3, 7)","7","7>3!","Incorreto") + "\n" + eqs("Solution.MaiorDe(\"a\", \"z\")","z","z>a!","Incorreto"))),
    ("Deconstruction","Use deconstruction.",["tuple","deconstruct"],
     "public class Ponto\n{\n    public double X { get; set; }\n    public double Y { get; set; }\n    public void Deconstruct(out double x, out double y) { x = X; y = Y; }\n}\n\npublic class Solution\n{\n    public static double Teste()\n    {\n        var p = new Ponto { X = 3, Y = 4 };\n        var (x, y) = p;\n        return x + y;\n    }\n}",
     tc(check("Math.Abs(Solution.Teste() - 7.0) < 0.01","3+4=7!","Incorreto"))),
    ("Nullable Reference","Use nullable reference types.",["nullable","referência"],
     "#nullable enable\n\npublic class Solution\n{\n    public static string Cumprimentar(string? nome)\n    {\n        // Se nome null, retorne \"Olá, Visitante!\"\n        // Senão \"Olá, {nome}!\"\n        return \"\";\n    }\n}",
     tc(eqs("Solution.Cumprimentar(null)","Olá, Visitante!","Null ok!","Incorreto") + "\n" + eqs("Solution.Cumprimentar(\"Ana\")","Olá, Ana!","Ana ok!","Incorreto"))),
    ("Range e Index","Use ranges e indices.",["range","index"],
     "public class Solution\n{\n    public static int[] UltimosTres(int[] arr)\n    {\n        // Use range [^3..] para pegar últimos 3\n        return new int[0];\n    }\n}",
     tc(check("Solution.UltimosTres(new[]{1,2,3,4,5}).SequenceEqual(new[]{3,4,5})","Últimos 3!","Incorreto"))),
]

for i,(t,d,tg,s,tcode) in enumerate(cs_adv,1):
    save({"id":f"csharp-adv-{i:03d}","track":"csharp","title":t,"description":d,"starterCode":s,
          "tags":tg,"difficulty":"Avancado","validatorType":"csharp-tests","validatorConfig":{"testCode":tcode}})

print(f"C#: {len(cs_ini)} ini + {len(cs_int)} int + {len(cs_adv)} adv = {len(cs_ini)+len(cs_int)+len(cs_adv)}")
